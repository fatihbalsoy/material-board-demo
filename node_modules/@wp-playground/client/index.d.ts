// Generated by dts-bundle-generator v7.2.0

import * as Comlink from 'comlink';
import { Remote } from 'comlink';

export interface MonitoredModule {
	dependencyFilename: string;
	dependenciesTotalSize: number;
}
declare class EmscriptenDownloadMonitor extends EventTarget {
	#private;
	constructor(modules?: MonitoredModule[]);
	getEmscriptenOptions(): {
		dataFileDownloads: Record<string, any>;
	};
	setModules(modules: MonitoredModule[]): void;
}
/**
 * Options for customizing the progress tracker.
 */
export interface ProgressTrackerOptions {
	/** The weight of the progress, a number between 0 and 1. */
	weight?: number;
	/** The caption to display during progress, a string. */
	caption?: string;
	/** The time in milliseconds to fill the progress, a number. */
	fillTime?: number;
}
/**
 * Custom event providing information about a loading process.
 */
export type LoadingEvent = CustomEvent<{
	/** The number representing how much was loaded. */
	loaded: number;
	/** The number representing how much needs to loaded in total. */
	total: number;
}>;
/**
 * Custom event providing progress details.
 */
export type ProgressTrackerEvent = CustomEvent<ProgressDetails>;
export interface ProgressDetails {
	/** The progress percentage as a number between 0 and 100. */
	progress: number;
	/** The caption to display during progress, a string. */
	caption: string;
}
/**
 * ProgressObserver A function that receives progress updates.
 *
 * @param progress The progress percentage as a number between 0 and 100.
 */
export type ProgressObserver = (progress: number) => void;
/**
 * Listener A function for handling specific event types.
 *
 * @param event The event of type T.
 */
export type Listener<T> = (event: T) => void;
export type TSCompatibleListener<T> = EventListenerOrEventListenerObject | null | Listener<T>;
export interface ProgressReceiver {
	setProgress(details: ProgressDetails): any;
	setLoaded(): any;
}
declare class ProgressTracker extends EventTarget {
	private _selfWeight;
	private _selfDone;
	private _selfProgress;
	private _selfCaption;
	private _weight;
	private _progressObserver?;
	private _loadingListener?;
	private _isFilling;
	private _fillTime;
	private _fillInterval?;
	private _subTrackers;
	constructor({ weight, caption, fillTime, }?: ProgressTrackerOptions);
	/**
	 * Creates a new sub-tracker with a specific weight.
	 *
	 * The weight determines what percentage of the overall progress
	 * the sub-tracker represents. For example, if the main tracker is
	 * monitoring a process that has two stages, and the first stage
	 * is expected to take twice as long as the second stage, you could
	 * create the first sub-tracker with a weight of 0.67 and the second
	 * sub-tracker with a weight of 0.33.
	 *
	 * The caption is an optional string that describes the current stage
	 * of the operation. If provided, it will be used as the progress caption
	 * for the sub-tracker. If not provided, the main tracker will look for
	 * the next sub-tracker with a non-empty caption and use that as the progress
	 * caption instead.
	 *
	 * Returns the newly-created sub-tracker.
	 *
	 * @throws {Error} If the weight of the new stage would cause the total weight of all stages to exceed 1.
	 *
	 * @param weight The weight of the new stage, as a decimal value between 0 and 1.
	 * @param caption The caption for the new stage, which will be used as the progress caption for the sub-tracker.
	 *
	 * @example
	 * ```ts
	 * const tracker = new ProgressTracker();
	 * const subTracker1 = tracker.stage(0.67, 'Slow stage');
	 * const subTracker2 = tracker.stage(0.33, 'Fast stage');
	 *
	 * subTracker2.set(50);
	 * subTracker1.set(75);
	 * subTracker2.set(100);
	 * subTracker1.set(100);
	 * ```
	 */
	stage(weight?: number, caption?: string): ProgressTracker;
	/**
	 * Fills the progress bar slowly over time, simulating progress.
	 *
	 * The progress bar is filled in a 100 steps, and each step, the progress
	 * is increased by 1. If `stopBeforeFinishing` is true, the progress bar
	 * will stop filling when it reaches 99% so that you can call `finish()`
	 * explicitly.
	 *
	 * If the progress bar is filling or already filled, this method does nothing.
	 *
	 * @example
	 * ```ts
	 * const progress = new ProgressTracker({ caption: 'Processing...' });
	 * progress.fillSlowly();
	 * ```
	 *
	 * @param options Optional options.
	 */
	fillSlowly({ stopBeforeFinishing }?: {
		stopBeforeFinishing?: boolean | undefined;
	}): void;
	set(value: number): void;
	finish(): void;
	get caption(): string;
	setCaption(caption: string): void;
	get done(): boolean;
	get progress(): number;
	get weight(): number;
	get observer(): ProgressObserver;
	get loadingListener(): Listener<LoadingEvent>;
	pipe(receiver: ProgressReceiver): void;
	addEventListener(type: string, listener: TSCompatibleListener<ProgressTrackerEvent>): void;
	removeEventListener(type: string, listener: TSCompatibleListener<ProgressTrackerEvent>): void;
	private notifyProgress;
	private notifyDone;
}
export interface PHPResponseData {
	/**
	 * Response headers.
	 */
	readonly headers: Record<string, string[]>;
	/**
	 * Response body. Contains the output from `echo`,
	 * `print`, inline HTML etc.
	 */
	readonly bytes: ArrayBuffer;
	/**
	 * Stderr contents, if any.
	 */
	readonly errors: string;
	/**
	 * The exit code of the script. `0` is a success, while
	 * `1` and `2` indicate an error.
	 */
	readonly exitCode: number;
	/**
	 * Response HTTP status code, e.g. 200.
	 */
	readonly httpStatusCode: number;
}
/**
 * PHP response. Body is an `ArrayBuffer` because it can
 * contain binary data.
 *
 * This type is used in Comlink.transferHandlers.set('PHPResponse', \{ ... \})
 * so be sure to update that if you change this type.
 */
export declare class PHPResponse implements PHPResponseData {
	/** @inheritDoc */
	readonly headers: Record<string, string[]>;
	/** @inheritDoc */
	readonly bytes: ArrayBuffer;
	/** @inheritDoc */
	readonly errors: string;
	/** @inheritDoc */
	readonly exitCode: number;
	/** @inheritDoc */
	readonly httpStatusCode: number;
	constructor(httpStatusCode: number, headers: Record<string, string[]>, body: ArrayBuffer, errors?: string, exitCode?: number);
	static fromRawData(data: PHPResponseData): PHPResponse;
	toRawData(): PHPResponseData;
	/**
	 * Response body as JSON.
	 */
	get json(): any;
	/**
	 * Response body as text.
	 */
	get text(): string;
}
/**
 * Handles HTTP requests using PHP runtime as a backend.
 *
 * @public
 * @example Use PHPRequestHandler implicitly with a new PHP instance:
 * ```js
 * import { PHP } from '@php-wasm/web';
 *
 * const php = await PHP.load( '7.4', {
 *     requestHandler: {
 *         // PHP FS path to serve the files from:
 *         documentRoot: '/www',
 *
 *         // Used to populate $_SERVER['SERVER_NAME'] etc.:
 *         absoluteUrl: 'http://127.0.0.1'
 *     }
 * } );
 *
 * php.mkdirTree('/www');
 * php.writeFile('/www/index.php', '<?php echo "Hi from PHP!"; ');
 *
 * const response = await php.request({ path: '/index.php' });
 * console.log(response.text);
 * // "Hi from PHP!"
 * ```
 *
 * @example Explicitly create a PHPRequestHandler instance and run a PHP script:
 * ```js
 * import {
 *   loadPHPRuntime,
 *   PHP,
 *   PHPRequestHandler,
 *   getPHPLoaderModule,
 * } from '@php-wasm/web';
 *
 * const runtime = await loadPHPRuntime( await getPHPLoaderModule('7.4') );
 * const php = new PHP( runtime );
 *
 * php.mkdirTree('/www');
 * php.writeFile('/www/index.php', '<?php echo "Hi from PHP!"; ');
 *
 * const server = new PHPRequestHandler(php, {
 *     // PHP FS path to serve the files from:
 *     documentRoot: '/www',
 *
 *     // Used to populate $_SERVER['SERVER_NAME'] etc.:
 *     absoluteUrl: 'http://127.0.0.1'
 * });
 *
 * const response = server.request({ path: '/index.php' });
 * console.log(response.text);
 * // "Hi from PHP!"
 * ```
 */
export interface RequestHandler {
	/**
	 * Serves the request – either by serving a static file, or by
	 * dispatching it to the PHP runtime.
	 * Cannot be used in conjunction with `cli()`.
	 *
	 * @example
	 * ```js
	 * const output = await php.request({
	 * 	method: 'GET',
	 * 	url: '/index.php',
	 * 	headers: {
	 * 		'X-foo': 'bar',
	 * 	},
	 * 	formData: {
	 * 		foo: 'bar',
	 * 	},
	 * });
	 * console.log(output.stdout); // "Hello world!"
	 * ```
	 *
	 * @param  request - PHP Request data.
	 */
	request(request: PHPRequest, maxRedirects?: number): Promise<PHPResponse>;
	/**
	 * Converts a path to an absolute URL based at the PHPRequestHandler
	 * root.
	 *
	 * @param  path The server path to convert to an absolute URL.
	 * @returns The absolute URL.
	 */
	pathToInternalUrl(path: string): string;
	/**
	 * Converts an absolute URL based at the PHPRequestHandler to a relative path
	 * without the server pathname and scope.
	 *
	 * @param  internalUrl An absolute URL based at the PHPRequestHandler root.
	 * @returns The relative path.
	 */
	internalUrlToPath(internalUrl: string): string;
	/**
	 * The absolute URL of this PHPRequestHandler instance.
	 */
	absoluteUrl: string;
	/**
	 * The directory in the PHP filesystem where the server will look
	 * for the files to serve. Default: `/var/www`.
	 */
	documentRoot: string;
}
export interface IsomorphicLocalPHP extends RequestHandler {
	setPhpIniPath(path: string): void;
	setPhpIniEntry(key: string, value: string): void;
	/**
	 * Recursively creates a directory with the given path in the PHP filesystem.
	 * For example, if the path is `/root/php/data`, and `/root` already exists,
	 * it will create the directories `/root/php` and `/root/php/data`.
	 *
	 * @param  path - The directory path to create.
	 */
	mkdir(path: string): void;
	/**
	 * @deprecated Use mkdir instead.
	 */
	mkdirTree(path: string): void;
	/**
	 * Reads a file from the PHP filesystem and returns it as a string.
	 *
	 * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsText(path: string): string;
	/**
	 * Reads a file from the PHP filesystem and returns it as an array buffer.
	 *
	 * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsBuffer(path: string): Uint8Array;
	/**
	 * Overwrites data in a file in the PHP filesystem.
	 * Creates a new file if one doesn't exist yet.
	 *
	 * @param  path - The file path to write to.
	 * @param  data - The data to write to the file.
	 */
	writeFile(path: string, data: string | Uint8Array): void;
	/**
	 * Removes a file from the PHP filesystem.
	 *
	 * @throws {@link @php-wasm/universal:ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to remove.
	 */
	unlink(path: string): void;
	/**
	 * Moves a file or directory in the PHP filesystem to a
	 * new location.
	 *
	 * @param oldPath The path to rename.
	 * @param newPath The new path.
	 */
	mv(oldPath: string, newPath: string): void;
	/**
	 * Removes a directory from the PHP filesystem.
	 *
	 * @param path The directory path to remove.
	 * @param options Options for the removal.
	 */
	rmdir(path: string, options?: RmDirOptions): void;
	/**
	 * Lists the files and directories in the given directory.
	 *
	 * @param  path - The directory path to list.
	 * @returns The list of files and directories in the given directory.
	 */
	listFiles(path: string): string[];
	/**
	 * Checks if a directory exists in the PHP filesystem.
	 *
	 * @param  path – The path to check.
	 * @returns True if the path is a directory, false otherwise.
	 */
	isDir(path: string): boolean;
	/**
	 * Checks if a file (or a directory) exists in the PHP filesystem.
	 *
	 * @param  path - The file path to check.
	 * @returns True if the file exists, false otherwise.
	 */
	fileExists(path: string): boolean;
	/**
	 * Changes the current working directory in the PHP filesystem.
	 * This is the directory that will be used as the base for relative paths.
	 * For example, if the current working directory is `/root/php`, and the
	 * path is `data`, the absolute path will be `/root/php/data`.
	 *
	 * @param  path - The new working directory.
	 */
	chdir(path: string): void;
	/**
	 * Runs PHP code.
	 * Cannot be used in conjunction with `cli()`.
	 *
	 * @example
	 * ```js
	 * const output = await php.run('<?php echo "Hello world!";');
	 * console.log(output.stdout); // "Hello world!"
	 * ```
	 *
	 * @example
	 * ```js
	 * console.log(await php.run(`<?php
	 *  $fp = fopen('php://stderr', 'w');
	 *  fwrite($fp, "Hello, world!");
	 * `));
	 * // {"exitCode":0,"stdout":"","stderr":["Hello, world!"]}
	 * ```
	 *
	 * @param  options - PHP run options.
	 */
	run(options: PHPRunOptions): Promise<PHPResponse>;
}
export type IsomorphicRemotePHP = Remote<IsomorphicLocalPHP>;
export type UniversalPHP = IsomorphicLocalPHP | IsomorphicRemotePHP;
export type HTTPMethod = "GET" | "POST" | "HEAD" | "OPTIONS" | "PATCH" | "PUT" | "DELETE";
export type PHPRequestHeaders = Record<string, string>;
export interface PHPRequest {
	/**
	 * Request method. Default: `GET`.
	 */
	method?: HTTPMethod;
	/**
	 * Request path or absolute URL.
	 */
	url: string;
	/**
	 * Request headers.
	 */
	headers?: PHPRequestHeaders;
	/**
	 * Uploaded files
	 */
	files?: Record<string, File>;
	/**
	 * Request body without the files.
	 */
	body?: string;
	/**
	 * Form data. If set, the request body will be ignored and
	 * the content-type header will be set to `application/x-www-form-urlencoded`.
	 */
	formData?: Record<string, unknown>;
}
export interface PHPRunOptions {
	/**
	 * Request path following the domain:port part.
	 */
	relativeUri?: string;
	/**
	 * Path of the .php file to execute.
	 */
	scriptPath?: string;
	/**
	 * Request protocol.
	 */
	protocol?: string;
	/**
	 * Request method. Default: `GET`.
	 */
	method?: HTTPMethod;
	/**
	 * Request headers.
	 */
	headers?: PHPRequestHeaders;
	/**
	 * Request body without the files.
	 */
	body?: string;
	/**
	 * Uploaded files.
	 */
	fileInfos?: FileInfo[];
	/**
	 * The code snippet to eval instead of a php file.
	 */
	code?: string;
}
/**
 * Output of the PHP.wasm runtime.
 */
export interface PHPOutput {
	/** Exit code of the PHP process. 0 means success, 1 and 2 mean error. */
	exitCode: number;
	/** Stdout data */
	stdout: ArrayBuffer;
	/** Stderr lines */
	stderr: string[];
}
export interface FileInfo {
	key: string;
	name: string;
	type: string;
	data: Uint8Array;
}
export interface RmDirOptions {
	/**
	 * If true, recursively removes the directory and all its contents.
	 * Default: true.
	 */
	recursive?: boolean;
}
/**
 * Emscripten's filesystem-related Exception.
 *
 * @see https://emscripten.org/docs/api_reference/Filesystem-API.html
 * @see https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/arch/emscripten/bits/errno.h
 * @see https://github.com/emscripten-core/emscripten/blob/38eedc630f17094b3202fd48ac0c2c585dbea31e/system/include/wasi/api.h#L336
 */
export interface ErrnoError extends Error {
	node?: any;
	errno: number;
	message: string;
}
export declare const SupportedPHPVersions: readonly [
	"8.2",
	"8.1",
	"8.0",
	"7.4",
	"7.3",
	"7.2",
	"7.1",
	"7.0",
	"5.6"
];
export declare const LatestSupportedPHPVersion: "8.2";
export declare const SupportedPHPVersionsList: string[];
export type SupportedPHPVersion = (typeof SupportedPHPVersions)[number];
export interface PHPRequestHandlerConfiguration {
	/**
	 * The directory in the PHP filesystem where the server will look
	 * for the files to serve. Default: `/var/www`.
	 */
	documentRoot?: string;
	/**
	 * Request Handler URL. Used to populate $_SERVER details like HTTP_HOST.
	 */
	absoluteUrl?: string;
	/**
	 * Callback used by the PHPRequestHandler to decide whether
	 * the requested path refers to a PHP file or a static file.
	 */
	isStaticFilePath?: (path: string) => boolean;
}
/** @inheritDoc */
export declare class PHPRequestHandler implements RequestHandler {
	#private;
	/**
	 * The PHP instance
	 */
	php: BasePHP;
	/**
	 * @param  php    - The PHP instance.
	 * @param  config - Request Handler configuration.
	 */
	constructor(php: BasePHP, config?: PHPRequestHandlerConfiguration);
	/** @inheritDoc */
	pathToInternalUrl(path: string): string;
	/** @inheritDoc */
	internalUrlToPath(internalUrl: string): string;
	get isRequestRunning(): boolean;
	/** @inheritDoc */
	get absoluteUrl(): string;
	/** @inheritDoc */
	get documentRoot(): string;
	/** @inheritDoc */
	request(request: PHPRequest): Promise<PHPResponse>;
}
export interface PHPBrowserConfiguration {
	/**
	 * Should handle redirects internally?
	 */
	handleRedirects?: boolean;
	/**
	 * The maximum number of redirects to follow internally. Once
	 * exceeded, request() will return the redirecting response.
	 */
	maxRedirects?: number;
}
/**
 * A fake web browser that handles PHPRequestHandler's cookies and redirects
 * internally without exposing them to the consumer.
 *
 * @public
 */
export declare class PHPBrowser implements RequestHandler {
	#private;
	requestHandler: PHPRequestHandler;
	/**
	 * @param  server - The PHP server to browse.
	 * @param  config - The browser configuration.
	 */
	constructor(requestHandler: PHPRequestHandler, config?: PHPBrowserConfiguration);
	/**
	 * Sends the request to the server.
	 *
	 * When cookies are present in the response, this method stores
	 * them and sends them with any subsequent requests.
	 *
	 * When a redirection is present in the response, this method
	 * follows it by discarding a response and sending a subsequent
	 * request.
	 *
	 * @param  request   - The request.
	 * @param  redirects - Internal. The number of redirects handled so far.
	 * @returns PHPRequestHandler response.
	 */
	request(request: PHPRequest, redirects?: number): Promise<PHPResponse>;
	/** @inheritDoc */
	pathToInternalUrl(path: string): string;
	/** @inheritDoc */
	internalUrlToPath(internalUrl: string): string;
	/** @inheritDoc */
	get absoluteUrl(): string;
	/** @inheritDoc */
	get documentRoot(): string;
}
export type RuntimeType = "NODE" | "WEB" | "WORKER";
export type PHPRuntimeId = number;
export type PHPRuntime = any;
export type DataModule = {
	dependencyFilename: string;
	dependenciesTotalSize: number;
	default: (phpRuntime: PHPRuntime) => void;
};
export type EmscriptenOptions = {
	onAbort?: (message: string) => void;
	ENV?: Record<string, string>;
	locateFile?: (path: string) => string;
	noInitialRun?: boolean;
	dataFileDownloads?: Record<string, number>;
	print?: (message: string) => void;
	printErr?: (message: string) => void;
	onRuntimeInitialized?: () => void;
	monitorRunDependencies?: (left: number) => void;
} & Record<string, any>;
declare const __private__dont__use: unique symbol;
declare abstract class BasePHP implements IsomorphicLocalPHP {
	#private;
	protected [__private__dont__use]: any;
	requestHandler?: PHPBrowser;
	/**
	 * Initializes a PHP runtime.
	 *
	 * @internal
	 * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
	 * @param  serverOptions - Optional. Options for the PHPRequestHandler. If undefined, no request handler will be initialized.
	 */
	constructor(PHPRuntimeId?: PHPRuntimeId, serverOptions?: PHPRequestHandlerConfiguration);
	/** @inheritDoc */
	get absoluteUrl(): string;
	/** @inheritDoc */
	get documentRoot(): string;
	/** @inheritDoc */
	pathToInternalUrl(path: string): string;
	/** @inheritDoc */
	internalUrlToPath(internalUrl: string): string;
	initializeRuntime(runtimeId: PHPRuntimeId): void;
	/** @inheritDoc */
	setPhpIniPath(path: string): void;
	/** @inheritDoc */
	setPhpIniEntry(key: string, value: string): void;
	/** @inheritDoc */
	chdir(path: string): void;
	/** @inheritDoc */
	request(request: PHPRequest, maxRedirects?: number): Promise<PHPResponse>;
	/** @inheritDoc */
	run(request: PHPRunOptions): Promise<PHPResponse>;
	addServerGlobalEntry(key: string, value: string): void;
	/** @inheritDoc */
	mkdir(path: string): void;
	/** @inheritDoc */
	mkdirTree(path: string): void;
	/** @inheritDoc */
	readFileAsText(path: string): string;
	/** @inheritDoc */
	readFileAsBuffer(path: string): Uint8Array;
	/** @inheritDoc */
	writeFile(path: string, data: string | Uint8Array): void;
	/** @inheritDoc */
	unlink(path: string): void;
	/** @inheritDoc */
	mv(fromPath: string, toPath: string): void;
	/** @inheritDoc */
	rmdir(path: string, options?: RmDirOptions): void;
	/** @inheritDoc */
	listFiles(path: string): string[];
	/** @inheritDoc */
	isDir(path: string): boolean;
	/** @inheritDoc */
	fileExists(path: string): boolean;
}
export interface SemaphoreOptions {
	concurrency: number;
}
declare class Semaphore {
	private _running;
	private concurrency;
	private queue;
	constructor({ concurrency }: SemaphoreOptions);
	get running(): number;
	acquire(): Promise<() => void>;
	run<T>(fn: () => Promise<T>): Promise<T>;
}
export declare function phpVar(value: unknown): string;
export declare function phpVars<T extends Record<string, unknown>>(vars: T): Record<keyof T, string>;
export declare const ResourceTypes: readonly [
	"vfs",
	"literal",
	"wordpress.org/themes",
	"wordpress.org/plugins",
	"url"
];
export type VFSReference = {
	/** Identifies the file resource as Virtual File System (VFS) */
	resource: "vfs";
	/** The path to the file in the VFS */
	path: string;
};
export type LiteralReference = {
	/** Identifies the file resource as a literal file */
	resource: "literal";
	/** The name of the file */
	name: string;
	/** The contents of the file */
	contents: string | Uint8Array;
};
export type CoreThemeReference = {
	/** Identifies the file resource as a WordPress Core theme */
	resource: "wordpress.org/themes";
	/** The slug of the WordPress Core theme */
	slug: string;
};
export type CorePluginReference = {
	/** Identifies the file resource as a WordPress Core plugin */
	resource: "wordpress.org/plugins";
	/** The slug of the WordPress Core plugin */
	slug: string;
};
export type UrlReference = {
	/** Identifies the file resource as a URL */
	resource: "url";
	/** The URL of the file */
	url: string;
	/** Optional caption for displaying a progress message */
	caption?: string;
};
export type FileReference = VFSReference | LiteralReference | CoreThemeReference | CorePluginReference | UrlReference;
export interface ResourceOptions {
	/** Optional semaphore to limit concurrent downloads */
	semaphore?: Semaphore;
	progress?: ProgressTracker;
}
export declare abstract class Resource {
	/** Optional progress tracker to monitor progress */
	abstract progress?: ProgressTracker;
	/** A Promise that resolves to the file contents */
	protected promise?: Promise<File>;
	protected playground?: UniversalPHP;
	/**
	 * Creates a new Resource based on the given file reference
	 *
	 * @param ref The file reference to create the Resource for
	 * @param options Additional options for the Resource
	 * @returns A new Resource instance
	 */
	static create(ref: FileReference, { semaphore, progress }: ResourceOptions): Resource;
	setPlayground(playground: UniversalPHP): void;
	/**
	 * Resolves the file contents
	 * @returns The resolved file.
	 */
	abstract resolve(): Promise<File>;
	/** The name of the referenced file */
	abstract get name(): string;
	/** Whether this Resource is loaded asynchronously */
	get isAsync(): boolean;
}
/**
 * A `Resource` that represents a file in the VFS (virtual file system) of the playground.
 */
export declare class VFSResource extends Resource {
	private resource;
	progress?: ProgressTracker | undefined;
	/**
	 * Creates a new instance of `VFSResource`.
	 * @param playground The playground client.
	 * @param resource The VFS reference.
	 * @param progress The progress tracker.
	 */
	constructor(resource: VFSReference, progress?: ProgressTracker | undefined);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/** @inheritDoc */
	get name(): string;
}
/**
 * A `Resource` that represents a literal file.
 */
export declare class LiteralResource extends Resource {
	private resource;
	progress?: ProgressTracker | undefined;
	/**
	 * Creates a new instance of `LiteralResource`.
	 * @param resource The literal reference.
	 * @param progress The progress tracker.
	 */
	constructor(resource: LiteralReference, progress?: ProgressTracker | undefined);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/** @inheritDoc */
	get name(): string;
}
/**
 * A base class for `Resource`s that require fetching data from a remote URL.
 */
export declare abstract class FetchResource extends Resource {
	progress?: ProgressTracker | undefined;
	/**
	 * Creates a new instance of `FetchResource`.
	 * @param progress The progress tracker.
	 */
	constructor(progress?: ProgressTracker | undefined);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/**
	 * Gets the URL to fetch the data from.
	 * @returns The URL.
	 */
	protected abstract getURL(): string;
	/**
	 * Gets the caption for the progress tracker.
	 * @returns The caption.
	 */
	protected get caption(): string;
	/** @inheritDoc */
	get name(): string;
	/** @inheritDoc */
	get isAsync(): boolean;
}
/**
 * A `Resource` that represents a file available from a URL.
 */
export declare class UrlResource extends FetchResource {
	private resource;
	/**
	 * Creates a new instance of `UrlResource`.
	 * @param resource The URL reference.
	 * @param progress The progress tracker.
	 */
	constructor(resource: UrlReference, progress?: ProgressTracker);
	/** @inheritDoc */
	getURL(): string;
	/** @inheritDoc */
	protected get caption(): string;
}
export declare function setPluginProxyURL(url: string): void;
/**
 * A `Resource` that represents a WordPress core theme.
 */
export declare class CoreThemeResource extends FetchResource {
	private resource;
	constructor(resource: CoreThemeReference, progress?: ProgressTracker);
	get name(): string;
	getURL(): string;
}
/**
 * A resource that fetches a WordPress plugin from wordpress.org.
 */
export declare class CorePluginResource extends FetchResource {
	private resource;
	constructor(resource: CorePluginReference, progress?: ProgressTracker);
	/** @inheritDoc */
	get name(): string;
	/** @inheritDoc */
	getURL(): string;
}
/**
 * A decorator for a resource that adds functionality such as progress tracking and caching.
 */
export declare class DecoratedResource<T extends Resource> extends Resource {
	private resource;
	constructor(resource: T);
	/** @inheritDoc */
	resolve(): Promise<File>;
	/** @inheritDoc */
	setPlayground(playground: UniversalPHP): Promise<void>;
	/** @inheritDoc */
	get progress(): ProgressTracker | undefined;
	/** @inheritDoc */
	set progress(value: ProgressTracker | undefined);
	/** @inheritDoc */
	get name(): string;
	/** @inheritDoc */
	get isAsync(): boolean;
}
/**
 * A decorator for a resource that adds caching functionality.
 */
export declare class CachedResource<T extends Resource> extends DecoratedResource<T> {
	protected promise?: Promise<File>;
	/** @inheritDoc */
	resolve(): Promise<File>;
}
/**
 * A decorator for a resource that adds concurrency control functionality through a semaphore.
 */
export declare class SemaphoreResource<T extends Resource> extends DecoratedResource<T> {
	private readonly semaphore;
	constructor(resource: T, semaphore: Semaphore);
	/** @inheritDoc */
	resolve(): Promise<File>;
}
export interface ActivatePluginStep {
	step: "activatePlugin";
	plugin: string;
}
/**
 * Activates a WordPress plugin in the Playground.
 *
 * @param playground The playground client.
 * @param plugin The plugin slug.
 */
export declare const activatePlugin: StepHandler<ActivatePluginStep>;
export interface ApplyWordPressPatchesStep {
	step: "applyWordPressPatches";
	siteUrl: string;
	wordpressPath?: string;
	patchSqlitePlugin?: boolean;
	addPhpInfo?: boolean;
	patchSiteUrl?: boolean;
	disableSiteHealth?: boolean;
	disableWpNewBlogNotification?: boolean;
}
export declare const applyWordPressPatches: StepHandler<ApplyWordPressPatchesStep>;
export interface DefineSiteUrlStep {
	step: "defineSiteUrl";
	siteUrl: string;
}
/**
 * Sets site URL of the WordPress installation.
 *
 * @param playground The playground client.
 * @param siteUrl
 */
export declare const defineSiteUrl: StepHandler<DefineSiteUrlStep>;
/**
 * Full site export support:
 */
/**
 * Export the current site as a zip file.
 *
 * @param playground Playground client.
 */
export declare function zipEntireSite(playground: UniversalPHP): Promise<File>;
export interface ReplaceSiteStep<ResourceType> {
	step: "replaceSite";
	fullSiteZip: ResourceType;
}
/**
 * Replace the current site with the contents of a full site zip file.
 *
 * @param playground Playground client.
 * @param fullSiteZip Zipped WordPress site.
 */
export declare const replaceSite: StepHandler<ReplaceSiteStep<File>>;
export interface UnzipStep {
	step: "unzip";
	zipPath: string;
	extractToPath: string;
}
/**
 * Unzip a zip file.
 *
 * @param playground Playground client.
 * @param zipPath The zip file to unzip.
 * @param extractTo The directory to extract the zip file to.
 */
export declare const unzip: StepHandler<UnzipStep>;
export interface ImportFileStep<ResourceType> {
	step: "importFile";
	file: ResourceType;
}
/**
 * Uploads a file to the WordPress importer and returns the response.
 * Supports both WXR and WXZ files.
 *
 * @see https://github.com/WordPress/wordpress-importer/compare/master...akirk:wordpress-importer:import-wxz.patch
 * @param playground Playground client.
 * @param file The file to import.
 */
export declare const importFile: StepHandler<ImportFileStep<File>>;
export interface InstallPluginStep<ResourceType> {
	step: "installPlugin";
	pluginZipFile: ResourceType;
	options?: InstallPluginOptions;
}
export interface InstallPluginOptions {
	/**
	 * Whether to activate the plugin after installing it.
	 */
	activate?: boolean;
}
/**
 * Installs a WordPress plugin in the Playground.
 * Technically, it uses the same plugin upload form as a WordPress user
 * would, and then activates the plugin if needed.
 *
 * @param playground The playground client.
 * @param pluginZipFile The plugin zip file.
 * @param options Optional. Set `activate` to false if you don't want to activate the plugin.
 */
export declare const installPlugin: StepHandler<InstallPluginStep<File>>;
export interface InstallThemeStep<ResourceType> {
	step: "installTheme";
	themeZipFile: ResourceType;
	options?: InstallThemeOptions;
}
export interface InstallThemeOptions {
	/**
	 * Whether to activate the theme after installing it.
	 */
	activate?: boolean;
}
/**
 * Installs a WordPress theme in the Playground.
 * Technically, it uses the same theme upload form as a WordPress user
 * would, and then activates the theme if needed.
 *
 * @param playground The playground client.
 * @param themeZipFile The theme zip file.
 * @param options Optional. Set `activate` to false if you don't want to activate the theme.
 */
export declare const installTheme: StepHandler<InstallThemeStep<File>>;
export type LoginStep = {
	step: "login";
	username?: string;
	password?: string;
};
/**
 * Logs in to the Playground.
 * Under the hood, this function submits the wp-login.php form
 * just like a user would.
 *
 * @param playground The playground client.
 * @param user The user to log in as. Defaults to 'admin'.
 * @param password The password to log in with. Defaults to 'password'.
 */
export declare const login: StepHandler<LoginStep>;
export interface RunWpInstallationWizardStep {
	step: "runWpInstallationWizard";
	options: WordPressInstallationOptions;
}
export interface WordPressInstallationOptions {
	adminUsername?: string;
	adminPassword?: string;
}
/**
 * Installs WordPress
 *
 * @param playground The playground client.
 * @param options Installation options.
 */
export declare const runWpInstallationWizard: StepHandler<RunWpInstallationWizardStep>;
export type SetSiteOptionsStep = {
	step: "setSiteOptions";
	options: Record<string, unknown>;
};
export declare const setSiteOptions: StepHandler<SetSiteOptionsStep>;
export interface UpdateUserMetaStep {
	step: "updateUserMeta";
	meta: Record<string, unknown>;
	userId: number;
}
export declare const updateUserMeta: StepHandler<UpdateUserMetaStep>;
export interface RunPHPStep {
	step: "runPHP";
	code: string;
}
export declare const runPHP: StepHandler<RunPHPStep>;
export interface RunPHPWithOptionsStep {
	step: "runPHPWithOptions";
	options: PHPRunOptions;
}
export declare const runPHPWithOptions: StepHandler<RunPHPWithOptionsStep>;
export interface SetPhpIniEntryStep {
	step: "setPhpIniEntry";
	key: string;
	value: string;
}
export declare const setPhpIniEntry: StepHandler<SetPhpIniEntryStep>;
export interface RequestStep {
	step: "request";
	request: PHPRequest;
}
export declare const request: StepHandler<RequestStep>;
export interface CpStep {
	step: "cp";
	fromPath: string;
	toPath: string;
}
export declare const cp: StepHandler<CpStep>;
export interface MvStep {
	step: "mv";
	fromPath: string;
	toPath: string;
}
export declare const mv: StepHandler<MvStep>;
export interface MkdirStep {
	step: "mkdir";
	path: string;
}
export declare const mkdir: StepHandler<MkdirStep>;
export interface RmStep {
	step: "rm";
	path: string;
}
export declare const rm: StepHandler<RmStep>;
export interface RmdirStep {
	step: "rmdir";
	path: string;
}
export declare const rmdir: StepHandler<RmdirStep>;
export interface WriteFileStep<ResourceType> {
	step: "writeFile";
	path: string;
	data: ResourceType | string | Uint8Array;
}
export declare const writeFile: StepHandler<WriteFileStep<File>>;
export type Step = GenericStep<FileReference>;
export type StepDefinition = Step & {
	progress?: {
		weight?: number;
		caption?: string;
	};
};
export type GenericStep<Resource> = ActivatePluginStep | ApplyWordPressPatchesStep | CpStep | DefineSiteUrlStep | ImportFileStep<Resource> | InstallPluginStep<Resource> | InstallThemeStep<Resource> | LoginStep | MkdirStep | MvStep | RequestStep | ReplaceSiteStep<Resource> | RmStep | RmdirStep | RunPHPStep | RunPHPWithOptionsStep | RunWpInstallationWizardStep | SetPhpIniEntryStep | SetSiteOptionsStep | UnzipStep | UpdateUserMetaStep | WriteFileStep<Resource>;
export type StepHandler<S extends GenericStep<File>> = (php: UniversalPHP, args: Omit<S, "step">, progressArgs?: {
	tracker: ProgressTracker;
	initialCaption?: string;
}) => any;
export interface Blueprint {
	/**
	 * The URL to navigate to after the blueprint has been run.
	 */
	landingPage?: string;
	/**
	 * The preferred PHP and WordPress versions to use.
	 */
	preferredVersions?: {
		/**
		 * The preferred PHP version to use.
		 * If not specified, the latest supported version will be used
		 */
		php: SupportedPHPVersion | "latest";
		/**
		 * The preferred WordPress version to use.
		 * If not specified, the latest supported version will be used
		 */
		wp: string | "latest";
	};
	/**
	 * The steps to run.
	 */
	steps?: Array<StepDefinition | string | undefined | false | null>;
}
export type CompiledStep = (php: UniversalPHP) => Promise<void> | void;
declare const supportedWordPressVersions: readonly [
	"6.2",
	"6.1",
	"6.0",
	"5.9"
];
export type supportedWordPressVersion = (typeof supportedWordPressVersions)[number];
export interface CompiledBlueprint {
	/** The requested versions of PHP and WordPress for the blueprint */
	versions: {
		php: SupportedPHPVersion;
		wp: supportedWordPressVersion;
	};
	/** The compiled steps for the blueprint */
	run: (playground: UniversalPHP) => Promise<void>;
}
export type OnStepCompleted = (output: any, step: StepDefinition) => any;
export interface CompileBlueprintOptions {
	/** Optional progress tracker to monitor progress */
	progress?: ProgressTracker;
	/** Optional semaphore to control access to a shared resource */
	semaphore?: Semaphore;
	/** Optional callback with step output */
	onStepCompleted?: OnStepCompleted;
}
/**
 * Compiles Blueprint into a form that can be executed.
 *
 * @param playground The PlaygroundClient to use for the compilation
 * @param blueprint The bBueprint to compile
 * @param options Additional options for the compilation
 * @returns The compiled blueprint
 */
export declare function compileBlueprint(blueprint: Blueprint, { progress, semaphore, onStepCompleted, }?: CompileBlueprintOptions): CompiledBlueprint;
export declare function runBlueprintSteps(compiledBlueprint: CompiledBlueprint, playground: UniversalPHP): Promise<void>;
export type WithAPIState = {
	/**
	 * Resolves to true when the remote API is ready for
	 * Comlink communication, but not necessarily fully initialized yet.
	 */
	isConnected: () => Promise<void>;
	/**
	 * Resolves to true when the remote API is declares it's
	 * fully loaded and ready to be used.
	 */
	isReady: () => Promise<void>;
};
export type RemoteAPI<T> = Comlink.Remote<T & WithAPIState>;
export interface PHPWebLoaderOptions {
	emscriptenOptions?: EmscriptenOptions;
	downloadMonitor?: EmscriptenDownloadMonitor;
	requestHandler?: PHPRequestHandlerConfiguration;
	dataModules?: Array<DataModule | Promise<DataModule>>;
}
declare class WebPHP extends BasePHP {
	/**
	 * Creates a new PHP instance.
	 *
	 * Dynamically imports the PHP module, initializes the runtime,
	 * and sets up networking. It's a shorthand for the lower-level
	 * functions like `getPHPLoaderModule`, `loadPHPRuntime`, and
	 * `PHP.initializeRuntime`
	 *
	 * @param phpVersion The PHP Version to load
	 * @param options The options to use when loading PHP
	 * @returns A new PHP instance
	 */
	static load(phpVersion: SupportedPHPVersion, options?: PHPWebLoaderOptions): Promise<WebPHP>;
	/**
	 * Does what load() does, but synchronously returns
	 * an object with the PHP instance and a promise that
	 * resolves when the PHP instance is ready.
	 *
	 * @see load
	 */
	static loadSync(phpVersion: SupportedPHPVersion, options?: PHPWebLoaderOptions): {
		php: WebPHP;
		phpReady: Promise<WebPHP>;
		dataModules: Promise<DataModule[]>;
	};
}
declare class WebPHPEndpoint implements IsomorphicLocalPHP {
	/** @inheritDoc */
	absoluteUrl: string;
	/** @inheritDoc */
	documentRoot: string;
	/** @inheritDoc */
	constructor(php: BasePHP, monitor?: EmscriptenDownloadMonitor);
	/** @inheritDoc */
	pathToInternalUrl(path: string): string;
	/** @inheritDoc */
	internalUrlToPath(internalUrl: string): string;
	onDownloadProgress(callback: (progress: CustomEvent<ProgressEvent>) => void): Promise<void>;
	/** @inheritDoc */
	mv(fromPath: string, toPath: string): void;
	/** @inheritDoc */
	rmdir(path: string, options?: RmDirOptions): void;
	/** @inheritDoc @php-wasm/universal!RequestHandler.request */
	request(request: PHPRequest, redirects?: number): Promise<PHPResponse>;
	/** @inheritDoc @php-wasm/web!WebPHP.run */
	run(request: PHPRunOptions): Promise<PHPResponse>;
	/** @inheritDoc @php-wasm/web!WebPHP.chdir */
	chdir(path: string): void;
	/** @inheritDoc @php-wasm/web!WebPHP.setPhpIniPath */
	setPhpIniPath(path: string): void;
	/** @inheritDoc @php-wasm/web!WebPHP.setPhpIniEntry */
	setPhpIniEntry(key: string, value: string): void;
	/** @inheritDoc @php-wasm/web!WebPHP.mkdir */
	mkdir(path: string): void;
	/** @inheritDoc @php-wasm/web!WebPHP.mkdirTree */
	mkdirTree(path: string): void;
	/** @inheritDoc @php-wasm/web!WebPHP.readFileAsText */
	readFileAsText(path: string): string;
	/** @inheritDoc @php-wasm/web!WebPHP.readFileAsBuffer */
	readFileAsBuffer(path: string): Uint8Array;
	/** @inheritDoc @php-wasm/web!WebPHP.writeFile */
	writeFile(path: string, data: string | Uint8Array): void;
	/** @inheritDoc @php-wasm/web!WebPHP.unlink */
	unlink(path: string): void;
	/** @inheritDoc @php-wasm/web!WebPHP.listFiles */
	listFiles(path: string): string[];
	/** @inheritDoc @php-wasm/web!WebPHP.isDir */
	isDir(path: string): boolean;
	/** @inheritDoc @php-wasm/web!WebPHP.fileExists */
	fileExists(path: string): boolean;
}
declare class PlaygroundWorkerEndpoint extends WebPHPEndpoint {
	scope: string;
	wordPressVersion: string;
	phpVersion: string;
	constructor(php: WebPHP, monitor: EmscriptenDownloadMonitor, scope: string, wordPressVersion: string, phpVersion: string);
	getWordPressModuleDetails(): Promise<{
		staticAssetsDirectory: string;
		defaultTheme: any;
	}>;
}
export interface ProgressBarOptions {
	caption?: string;
	progress?: number;
	isIndefinite?: boolean;
	visible?: boolean;
}
export interface WebClientMixin extends ProgressReceiver {
	setProgress(options: ProgressBarOptions): Promise<void>;
	setLoaded(): Promise<void>;
	onNavigation(fn: (url: string) => void): Promise<void>;
	goTo(requestedPath: string): Promise<void>;
	getCurrentURL(): Promise<string>;
	setIframeSandboxFlags(flags: string[]): Promise<void>;
	onDownloadProgress: PlaygroundWorkerEndpoint["onDownloadProgress"];
}
/**
 * @inheritDoc
 */
export type PlaygroundClient = RemoteAPI<PlaygroundWorkerEndpoint & WebClientMixin>;
export interface StartPlaygroundOptions {
	iframe: HTMLIFrameElement;
	remoteUrl: string;
	progressTracker?: ProgressTracker;
	disableProgressBar?: boolean;
	blueprint?: Blueprint;
	onBlueprintStepCompleted?: OnStepCompleted;
}
/**
 * Loads playground in iframe and returns a PlaygroundClient instance.
 *
 * @param iframe Any iframe with Playground's remote.html loaded.
 * @param options Options for loading the playground.
 * @returns A PlaygroundClient instance.
 */
export declare function startPlaygroundWeb({ iframe, blueprint, remoteUrl, progressTracker, disableProgressBar, onBlueprintStepCompleted, }: StartPlaygroundOptions): Promise<PlaygroundClient>;
/**
 * @deprecated Use `startPlayground` instead.
 *
 * @param iframe Any iframe with Playground's remote.html loaded.
 * @param options Optional. If `loadRemote` is set, the iframe's `src` will be set to that URL.
 *                In other words, use this option if your iframe doesn't have remote.html already
 * 				  loaded.
 */
export declare function connectPlayground(iframe: HTMLIFrameElement, options?: {
	loadRemote?: string;
}): Promise<PlaygroundClient>;

export {};
